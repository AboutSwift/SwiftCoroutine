<!DOCTYPE html>
<html lang="en">
  <head>
    <title>SwiftCoroutine  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="SwiftCoroutine  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">SwiftCoroutine Docs</a> (3% documented)</p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">SwiftCoroutine Reference</a>
        <img id="carat" src="img/carat.png" />
        SwiftCoroutine  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/CoFuture.html">CoFuture</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/CoPromise.html">CoPromise</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/CoFutureError.html">CoFutureError</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/CoroutineError.html">CoroutineError</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Extensions/URLSession.html">URLSession</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/Coroutine.html">Coroutine</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Coroutine/State.html">– State</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/Coroutine/StackSize.html">– StackSize</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/CoroutineDispatcher.html">CoroutineDispatcher</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/CoroutineTaskExecutor.html">CoroutineTaskExecutor</a>
              </li>
              <li class="nav-group-task">
                <a href="Structs/TaskScheduler.html">TaskScheduler</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <!--
  Title: SwiftCoroutine
  Description: Swift coroutines for iOS and macOS.
  Author: belozierov
  Keywords: swift, coroutines, coroutine, async/await
  -->

<p><img src="../master/Sources/logo.png" alt="Swift Coroutine"></p>

<p>Many languages such as Kotlin, JavaScript, Go, Rust, C++, and others already have <a href="https://en.wikipedia.org/wiki/Coroutine">coroutines</a> support, which makes the use of asynchronous code easier. Unfortunately, Apple is still behind on this feature. But this can be improved by a framework without the need to change the language.</p>

<p>This is the first implementation of <a href="https://en.wikipedia.org/wiki/Coroutine">coroutines</a> for Swift with macOS and iOS support of 64-bit systems (since support for 32-bit systems is no longer really relevant). The stackful coroutine approach is used because it has a minimal context switching overhead, high performance, and is best suited for implementation as a third-party framework.</p>

<p>The framework is fully integrated with <a href="https://developer.apple.com/documentation/DISPATCH">Dispatch</a> making it intuitive to use. It is built on the <a href="https://ru.wikipedia.org/wiki/Futures_and_promises">Futures and Promises</a> concept that facilitate the creation of extra extensions you might need. In addition, the framework can be easily used with the new <a href="https://developer.apple.com/documentation/combine">Combine</a> framework and its army of various <a href="https://developer.apple.com/documentation/combine/publisher">Publishers</a> and additional operators.</p>

<p>You can find some API similarity to the Kotlin coroutines, thanks to my friends Android developers who have constantly advised me on how it works.</p>
<h3 id='usage' class='heading'>Usage</h3>
<pre class="highlight swift"><code>
<span class="c1">//Main thread</span>

<span class="c1">//If coroutine is started with default parameters on the main thread,</span>
<span class="c1">//it will also run on the main DispatchQueue</span>
<span class="n">coroutine</span> <span class="p">{</span>
    <span class="c1">//extension that returns CoFuture&lt;(Data, URLResponse)&gt;</span>
    <span class="k">let</span> <span class="nv">future</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskFuture</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">imageURL</span><span class="p">)</span>

    <span class="c1">//await result that suspends coroutine and doesn't block the thread</span>
    <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="n">future</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span><span class="o">.</span><span class="n">data</span>

    <span class="c1">//coroutine is performed on the main thread, that's why we can set the image in UIImageView</span>
    <span class="k">self</span><span class="o">.</span><span class="n">imageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">data</span><span class="p">:</span> <span class="n">data</span><span class="p">)</span>

<span class="p">}</span><span class="o">.</span><span class="n">onError</span> <span class="p">{</span> <span class="n">error</span> <span class="k">in</span>
    <span class="c1">//error handling if needed</span>
<span class="p">}</span>
</code></pre>
<h3 id='requirements' class='heading'>Requirements</h3>

<ul>
<li>iOS 11.0+ / macOS 10.13+</li>
<li>Xcode 10.2+</li>
<li>Swift 5+</li>
</ul>
<h3 id='installation' class='heading'>Installation</h3>

<p><code>SwiftCoroutine</code> is available through the <a href="https://swift.org/package-manager">Swift Package Manager</a> for macOS and iOS.</p>
<h2 id='working-with-swift-coroutine' class='heading'>Working with Swift Coroutine</h2>
<h3 id='futures-and-promises' class='heading'>Futures and promises</h3>

<p>Futures and promises are represented by the respective <code><a href="Classes/CoFuture.html">CoFuture</a></code> class and its <code><a href="Classes/CoPromise.html">CoPromise</a></code> subclass, which are generics to the type they return. They are thread-safe and have the support of the basic required functionality, including <code>await</code> mechanism, <code>onResult</code> on completion, and using the <code>transform</code> function you can build chains.</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">makeSomeFuture</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">CoFuture</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">promise</span> <span class="o">=</span> <span class="kt">CoPromise</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="n">someAsyncFuncWithCompletion</span> <span class="p">{</span> <span class="n">int</span> <span class="k">in</span>
        <span class="n">promise</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="n">int</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">promise</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">future</span> <span class="o">=</span> <span class="nf">makeSomeFuture</span><span class="p">()</span><span class="o">.</span><span class="n">transformOutput</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">description</span> <span class="p">}</span> 
<span class="n">future</span><span class="o">.</span><span class="nf">onResult</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">global</span><span class="p">)</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="c1">//do some work with result of type Result&lt;String, Error&gt;</span>
<span class="p">}</span>
</code></pre>
<h3 id='async-await' class='heading'>Async/await</h3>

<p>The framework includes extensions to DispatchQueue and global functions that allow you to execute code on a specific queue that returns <code><a href="Classes/CoFuture.html">CoFuture</a></code>. You can wait for the result with the <code>await</code> function inside coroutine, which suspends it and does not block the thread, so you can do it, for example, on the main thread.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">future1</span><span class="p">:</span> <span class="kt">CoFuture</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">async</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//some work</span>
    <span class="k">return</span> <span class="mi">5</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">future2</span><span class="p">:</span> <span class="kt">CoFuture</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">async</span> <span class="p">{</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">//some work</span>
    <span class="k">return</span> <span class="mi">6</span>
<span class="p">}</span>

<span class="nf">coroutine</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">main</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="k">try</span> <span class="n">future1</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span> <span class="o">+</span> <span class="n">future2</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span> <span class="c1">//will await for 3 sec., doesn't block the thread</span>
    <span class="k">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"Sum is </span><span class="se">\(</span><span class="n">sum</span><span class="se">)</span><span class="s">"</span>
<span class="p">}</span>
</code></pre>
<h3 id='coroutines' class='heading'>Coroutines</h3>

<p>You can create coroutines with the DispatchQueue extension and the corresponding global functions. API is identical to <code>async</code> function, except that you can call await inside and suspend coroutines execution by resuming it when a <code><a href="Classes/CoFuture.html">CoFuture</a></code> result is available. This makes it possible to write within the coroutines asynchronous code as synchronous. If global <code>coroutine</code> function is started with default parameters on the main thread, coroutine will run on the main DispatchQueue else on global.</p>

<p>This is a stackful coroutines, so each coroutine has its own stack, and after its completion, gets into the pool for reuse. If the system needs more RAM, the pool deinitializes all free coroutines and deallocates extra memory.</p>

<p>The framework also gives you access to the <code><a href="Structs/Coroutine.html">Coroutine</a></code> class if you need more control or to write your own additional API.</p>
<pre class="highlight swift"><code><span class="n">coroutine</span> <span class="p">{</span>
     <span class="k">let</span> <span class="nv">coroutine</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Coroutine</span><span class="o">.</span><span class="nf">current</span><span class="p">()</span> <span class="c1">//get current coroutine if needed</span>
     <span class="n">someAsyncFuncWithCompletion</span> <span class="p">{</span>
         <span class="n">coroutine</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span> <span class="c1">//manual resume outside coroutine</span>
     <span class="p">}</span>
     <span class="n">coroutine</span><span class="o">.</span><span class="nf">suspend</span><span class="p">()</span> <span class="c1">//manual suspend inside coroutine</span>
<span class="p">}</span>
</code></pre>

<p>Also you can change Dispatcher inside coroutine with the <code>setDispatcher</code> function.</p>
<pre class="highlight swift"><code><span class="nf">coroutine</span><span class="p">(</span><span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">global</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//thread from global queue</span>
    <span class="k">try</span> <span class="kt">Coroutine</span><span class="o">.</span><span class="nf">setDispatcher</span><span class="p">(</span><span class="o">.</span><span class="n">main</span><span class="p">)</span>
    <span class="c1">//main thread</span>
<span class="p">}</span>
</code></pre>

<p>Or you can create coroutines without dispatcher.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">cor1</span> <span class="o">=</span> <span class="kt">Coroutine</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">cor2</span> <span class="o">=</span> <span class="kt">Coroutine</span><span class="p">()</span>

<span class="n">cor1</span><span class="o">.</span><span class="n">start</span> <span class="p">{</span>
    <span class="c1">//call 1</span>
    <span class="n">cor1</span><span class="o">.</span><span class="nf">suspend</span><span class="p">()</span>
    <span class="c1">//call 4</span>
<span class="p">}</span>
<span class="c1">//call 2</span>
<span class="n">cor2</span><span class="o">.</span><span class="n">start</span> <span class="p">{</span>
    <span class="c1">//call 3</span>
    <span class="n">cor1</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
    <span class="c1">//call 5</span>
<span class="p">}</span>
<span class="c1">//call 6</span>
</code></pre>
<h3 id='generators-alpha-version' class='heading'>Generators (alpha version)</h3>

<p>The framework also includes the <code>Generator</code> class that allows yield values after each iteration similar to C#, Python, etc. <a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)">generators</a>.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">generator</span> <span class="o">=</span> <span class="kt">Generator</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">yield</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..&lt;</span><span class="mi">100</span> <span class="p">{</span> <span class="nf">yield</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
<span class="n">generator</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">//return 0</span>
<span class="n">generator</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">//return 1</span>
<span class="n">generator</span><span class="o">.</span><span class="nf">next</span><span class="p">()</span> <span class="c1">//return 2</span>
</code></pre>
<h3 id='combine' class='heading'>Combine</h3>

<p>Apple has recently introduced a new reactive programming framework that makes writing asynchronous code easier and includes a lot of convenient and common functionality. This framework includes the <code>await</code> extension for all publishers that allows combining reactive programming and coroutines for higher productivity.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">publisher</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTaskPublisher</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(\</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">coroutine</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">data</span> <span class="o">=</span> <span class="k">try</span> <span class="n">publisher</span><span class="o">.</span><span class="nf">await</span><span class="p">()</span>
    <span class="c1">//do some work with data</span>
<span class="p">}</span>
</code></pre>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2020 <a class="link" href="" target="_blank" rel="external"></a>. All rights reserved. (Last updated: 2020-03-11)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.13.1</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
